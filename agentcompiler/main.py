from langchain.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
import os
from pydantic import BaseModel, Field
from dotenv import load_dotenv

load_dotenv()
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")


class AgentExecutionStep(BaseModel):
    agent_name: str = Field(
        description="The name of the specialized agent responsible for a specific step in the task."
    )
    action_description: str = Field(
        description="A detailed description of what the agent will do in this step."
    )
    agent_prompt: str = Field(
        description="The prompt to be sent to the agent for execution.")


class OrchestrationPlan(BaseModel):
    final_answer: str = Field(
        description="The conclusive output generated by coordinating multiple agents to solve the given task."
    )
    agent_execution_plan: list[AgentExecutionStep] = Field(
        description="A sequential list detailing the agents to be invoked and their responsibilities in the task pipeline."
    )


def generate_orchestration_plan(user_task: str) -> OrchestrationPlan:
    llm = ChatOpenAI(model_name="gpt-4o-mini", temperature=0)

    orchestration_prompt = ChatPromptTemplate.from_template(
        """
        You are an Orchestrator Agent responsible for planning and coordinating other specialized agents to solve complex tasks.

        Task: {user_task}

        Your responsibilities:
        1. Decompose the task into clear, actionable steps.
        2. Identify the most suitable agents to execute each step.
        3. Define the sequence of agent execution to ensure accurate and complete results.

        Example:
        Task: "If a car travels 60 km per hour, how long will it take to travel 180 km?"

        Execution Plan:
        - Step 1: Use a ParameterExtractor agent to identify speed and distance.
        - Step 2: Invoke TimeComputationAgent to calculate time using time = distance / speed.
        - Step 3: Call AnswerFormatterAgent to produce a clear, human-readable response.

        Output your reasoning and the ordered list of required agents to fulfill the task.
        """
    )

    formatted_prompt = orchestration_prompt.format(user_task=user_task)

    structured_llm = llm.with_structured_output(OrchestrationPlan)

    orchestration_plan = structured_llm.invoke(formatted_prompt)

    return orchestration_plan


def run_abstract_agent(action_description, agent_prompt, agent_name):
    llm = ChatOpenAI(model_name="gpt-4o-mini", temperature=0)

    prompt = ChatPromptTemplate.from_template(
        """
            You are an {agent_name} Agent.

            {agent_prompt}

            Task: {action_description}
            """
    )

    formatted_prompt = prompt.format(
        agent_name=agent_name, agent_prompt=agent_prompt, action_description=action_description)

    answer = llm.invoke(formatted_prompt)

    return answer


def run_list_of_agents(orchestration_plan):
    """
    This is a very simple implentation of this function, the idea here is to improve this to have a more compiler way of running the agents.
    Since we already have all the steps in a list, we could make this very fast.
    """
    last_answer = ""
    for step in orchestration_plan.agent_execution_plan:
        last_answer = run_abstract_agent(
            step.action_description, step.agent_prompt + f"Here is last agent answer {last_answer}", step.agent_name)
        print("Agent:", step.agent_name)
        print("Action Description:", step.action_description)
        print("Agent Prompt:", step.agent_prompt)
        print(last_answer.content)
        print()


if __name__ == "__main__":
    task_description = "Generate a website layout for a personal blog with a header, footer, and a main content section. Also it should has tests and be written in react"
    plan_result = generate_orchestration_plan(task_description)
    print("Orchestration Plan:", plan_result.agent_execution_plan)
    run_list_of_agents(plan_result)
